# coding: utf-8
import os
import re
import glob
import socket
from bstools.ipaddress import IPv4Address, IPv4Network
try: # PY2
    import httplib
except ImportError: # PY3
    import http.client as httplib

IFCFG_FPATH = "/etc/sysconfig/network-scripts/ifcfg-{}"
DNS_FPATH = "/etc/resolv.conf"

def _write_to_file(path, content):
    with open(path, 'w') as fp:
        fp.write(content)

def ifcfg_content(**kw):
    """生成ifcfg配置文件内容
    """
    if kw.get('bond_master'):
        config = """\
DEVICE='{bond_name}'
NAME='{bond_name}'
TYPE=Bond
BONDING_MASTER=yes
ONBOOT=yes
BOOTPROTO=none
IPV6INIT=yes
IPV6_AUTOCONF=no
BONDING_OPTS="mode=2 xmit_hash_policy=layer3+4 miimon=100 downdelay=200 updelay=200"
"""
        if kw.get('ip'):
            config += """\
IPADDR='{ip}'
NETMASK='{netmask}'
GATEWAY='{gateway}'
"""
        config = config.format(**kw)
    elif kw.get('bond_slave'):
        config = """\
DEVICE='{name}'
NAME='bond-slave'
TYPE=Ethernet
BOOTPROTO=none
ONBOOT=yes
MASTER='{bond_name}'
SLAVE=yes
""".format(**kw)
    elif kw.get('bond_sub'):
        config = """\
DEVICE='{bond_sub_name}'
NAME='{bond_sub_name}'
BOOTPROTO=none
ONBOOT=yes
IPADDR='{ip}'
NETMASK='{netmask}'
GATEWAY='{gateway}'
PHYSDEV='{bond_name}'
"""
    elif kw.get('dhcp'):
        config = """\
DEVICE='{name}'
NAME='{name}'
ONBOOT=yes
IPV6INIT=yes
BOOTPROTO=dhcp
""".format(**kw)
    else:
        config = """\
DEVICE='{name}'
NAME='{name}'
ONBOOT=yes
IPV6INIT=yes
BOOTPROTO=none
IPADDR='{ip}'
NETMASK='{netmask}'
GATEWAY='{gateway}'
""".format(**kw)
        
     # 添加MAC地址字段
    if not kw.get('bond_master') and not kw.get('bond_slave') and not kw.get('bond_sub'):
        mac = kw.get('mac')
        if mac:
            config += "HWADDR={}\n".format(mac)
            
    vlanid = get_vlanid_from_adapter_name(kw.get('name', ''))
    if vlanid:
        if "VLAN=yes" not in config:
            config += "VLAN=yes\n"

    return config

def chk_ifcfg_content(name,ip,netmask,gateway,vlan_id, language='ZH'):
    if vlan_id:
        vlan_id = int(vlan_id)
        if vlan_id <= 0 or vlan_id > 1024:
            return "vlan_id:{} error".format(vlan_id) if language != 'ZH' else "vlan_id错误"
        vlan_id_of_name = get_vlanid_from_adapter_name(name)
        if vlan_id_of_name:
            if vlan_id_of_name != vlan_id:
                return "vlan_id not match netcard" if language != 'ZH' else "vlan_id与网卡不匹配"
    if ip: # 支持不配ip
        ips = load_all_ifcfg_ip_except_someone(name)
        if ip in ips:
            return "ip already used" if language != 'ZH' else "ip已被使用"
        if not is_valid_ipv4_address(ip):
            return "ip format error" if language != 'ZH' else "ip格式错误"
        if not is_same_subnet(ip, gateway, netmask):
            return "ip and gateway not in same network" if language == 'ZH' else "ip和gateway不在同一网段"
    if netmask:
        if not is_valid_ipv4_address(netmask):
            return "netmask format error" if language != 'ZH' else "netmask格式错误"
    if gateway:
        if not is_valid_ipv4_address(gateway):
            return "gateway format error" if language != 'ZH' else "gateway格式错误"
        if ip == gateway:
            return "ip must different with gateway" if language != 'ZH' else "ip和gateway必须不同"
    return ''

def get_vlanid_from_adapter_name(name):
    vlanid = None
    try:
        vlanid = int(name.split(".")[1])
    except:
        pass

    return vlanid

def auto_ifcfg_static_ip(name, ip, netmask, gateway, mac=None):
    if name == "bond0":
        return ifcfg_bond_master(name,
                                 ip=ip,
                                 netmask=netmask,
                                 gateway=gateway)
    return ifcfg_static_ip(name, ip, netmask, gateway,mac=mac)


def ifcfg_static_ip(name, ip, netmask, gateway, mac=None):
    """生成ifcfg配置文件，并且写入到正确的路径"""
    config = ifcfg_content(name=name, ip=ip, netmask=netmask, gateway=gateway,mac=mac)
    path = IFCFG_FPATH.format(name)

    _write_to_file(path, config)

def ifcfg_dhcp_ip(name,mac=None):
    config = ifcfg_content(dhcp=True, name=name,mac=mac)
    path = IFCFG_FPATH.format(name)
    _write_to_file(path, config)

def ifcfg_bond_master(bond_name, ip='', netmask='', gateway='',mac=None):
    '''
    bond_name: bond0 bond1 ...
    '''
    config = ifcfg_content(bond_master=True, bond_name=bond_name,
                        ip=ip, netmask=netmask, gateway=gateway,mac=mac)
    path = IFCFG_FPATH.format(bond_name)
    _write_to_file(path, config)

def ifcfg_bond_slave(name, bond_name):
    config = ifcfg_content(
        bond_slave=True,
        name=name,
        bond_name=bond_name,
    )
    path = IFCFG_FPATH.format(name)
    _write_to_file(path, config)

def ifcfg_bond_sub(name, bond_name, bond_sub_name):
    config = ifcfg_content(bond_sub=True, bond_sub_name=bond_sub_name, name=name, bond_name=bond_name)
    path = IFCFG_FPATH.format(name)
    _write_to_file(path, config)


def load_ifcfg_content(name):
    path = IFCFG_FPATH.format(name)
    res = dict()
    try:
        with open(path, 'r') as fp:
            data = fp.read()
    except:
        return res
    for line in data.splitlines():
        ls = line.split("=")
        if len(ls) != 2:
            continue
        res[ls[0]] = ls[1].strip('\'"')
    return res

def load_all_ifcfg_ip_except_someone(except_ifcfg_name):
    ips = set()
    for f in glob.glob(IFCFG_FPATH.format("*")):
        name = os.path.basename(f)[6:]
        if name == except_ifcfg_name:
            continue
        ip = load_ifcfg_content(name).get('IPADDR')
        if ip:
            ips.add(ip)
    return ips

def resolv_content(nameservers):
    return "# Generated by win tty\n{}\n".format("\n".join(["nameserver {}".format(i) for i in nameservers]))

def cfg_resolv(nameservers):
    _write_to_file(DNS_FPATH, resolv_content(nameservers))

def load_resolv():
    nameservers = []
    with open("/etc/resolv.conf", "r") as f:
        for line in f.read().splitlines():
            l = line.split()
            if len(l) != 2:
                continue
            if l[0] == 'nameserver':
                nameservers.append(l[1])
    return nameservers


def restart_network_service():
    import subprocess
    try:
        subprocess.check_call("systemctl restart network".split())
    except subprocess.CalledProcessError:
        return False

    return True

def http_connect_test(host):
    conn = httplib.HTTPConnection(host, timeout=3)

    try:
        conn.request("HEAD", "/")
    except (socket.gaierror, socket.timeout):
        return False

    return True

def is_network_connectd():
    """探测网络是否已连通"""
    return any(http_connect_test(host) for host in ["baidu.com", "qq.com", "163.com"])

def is_valid_ipv4_address(address):
    try:
        IPv4Address(address.decode('utf-8'))
        return True
    except ValueError:
        return False


def is_same_subnet(ip1, ip2, mask):
    """
    判断两个 IP 是否属于同一个子网段

    :param ip1: 第一个 IP 地址，字符串类型，例如 '192.168.0.1'
    :param ip2: 第二个 IP 地址，字符串类型，例如 '192.168.0.2'
    :param mask: 子网掩码，字符串类型，例如 '255.255.255.0'
    :return: 如果两个 IP 属于同一个子网段，返回 True, 否则返回 False
    """
    ip1_addr = IPv4Address(ip1.decode('utf-8'))
    ip2_addr = IPv4Address(ip2.decode('utf-8'))
    network = IPv4Network(u'{0}/{1}'.format(ip1, mask), strict=False)

    return ip1_addr in network and ip2_addr in network


def chk_addr(addr):
    return re.match(r'^([0-9a-z\.:])+$', addr)

if __name__ == "__main__":
    assert is_same_subnet(u"1.1.1.1", u"1.1.1.2", u"255.255.255.0") is True
    assert is_same_subnet(u"1.1.1.1", u"2.1.1.2", u"255.255.255.0") is False
    print(resolv_content(["1.1.1.1", "8.8.8.8"]))

    print(load_ifcfg_content("enp0s8"))
    print(load_all_ifcfg_ip_except_someone(""))
